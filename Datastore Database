## Playerdata Module! ## (The New and Improved u.u)
local Players = game:GetService("Players")
local SSS = game:GetService("ServerScriptService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local storeService = game:GetService("DataStoreService")
local dataStore = storeService:GetDataStore("playerData")
local restoreData = storeService:GetDataStore("StoreData")

local getPlayerData = Instance.new("RemoteEvent")
getPlayerData.Name = "getPlayerData"
getPlayerData.Parent =  ReplicatedStorage

local getMinutes = Instance.new("RemoteEvent")
getMinutes.Name = "getMinutes"
getMinutes.Parent = ReplicatedStorage

local ModulesScripts = SSS.Modules

local leaderstats = require(ModulesScripts:WaitForChild("PlayerData"):WaitForChild("leaderstats"))

local playerData = {}
--Defining a few global variables within the module. These variables will be accessable in different functions
-- within the module
playerData.Inventory = {}
playerData.Achievements = {}
playerData.Data = {}
playerData.restoreData = {}
playerData.storeData = {}
local playerTime = {
	elasTime = 0,
	seconds = 0,
	minutes = 0,
	hours = 0,
	days = 0
}
playerData.runningTimer = true

--Function that'll remove the leaderstats folder, helpful because... we create a lot of folders here
local function removeFolder(player)
	local folder = player:FindFirstChild("leaderstats")
	if folder then
		print("Found Folder")
		folder:Destroy()
	end
end


local playerStats = { --Defining the player values aka what will display on the players leaderboard/leaderstats
	Level = 1,
	Gold = 100,
}

local function playerAdded(player: Player) -- In this function, am either finding the player's data or assigning default data to the player
	print("Running") -- print statement to tell if it is running or not
	-- These three values defined to be used later for a repeat loop. Giving the system/user 5 attempts to load the player's data before assigning new values.
	local Success = nil
	local Data = nil
	local Attempts = 1
	
	--This repeat loop is as I explained up there, repeats the function until data is found or until attempts == 5
	repeat Success, Data = pcall(function()
			return dataStore:GetAsync("playerData_" .. player.UserId) --Looking for the player's data saved within the key "playerData"
		end)
		
		--printing statements to help me debug the system and see where it is going wrong if something goes wrong.
		print(Success)
		print(Data)
		-- If success was = to false, the system should print "Failed to Load Data" on the output.
		if not Success then
			Attempts += 1
			print("Failed to Load Data, Trying again")
			task.wait(3)
		end
	until Success or Attempts == 5 --This line here is the reason it loops. If success is true, or attempts == 5, the loop will end.
	
	if Success and Data then
		playerData.Data[player.UserId] = Data
		leaderstats:Create(player, Data)
		return Data --returns the data
	end
	
	if not Data or Data == nil then --If the data isnt found, this will initiate the following statement
		print("Data not Found, Assigning default values") --print statement to let me know which statement is running
		playerData.createProfile(player) --Assigning default data to the user
	end
end

--This Function will be responsible for setting up the players data with the following data tables; playerData.Achievements[player], playerData.Inventory[player], playerData.Stats[player]
function playerData.createProfile(player: Player)
	--Defining Variables
	local runThrough = 0
	local timePlayed = 0
	local userData = {}

	--I am Initiating, or setting the value of, "playerData.Achievements" to ensure no errors and it is properly defined
	if not playerData.Achievements[player] then
		playerData.Achievements[player] = {}
	end
	--Defining variables
	local playerTable = playerData.Achievements[player]

	--These statements below is whats going to create my player's runthrough data and time played data. I am also setting the value of these variables to the player's data so that it is properly synced.
	local successRunthrough, errRunthrough = pcall(function()
		dataStore:SetAsync("Runthroughs_".. player.UserId, runThrough) --Setting up a Datastore sync for runthrough.
	end)

	local successTimePlayed, errTimePlayed = pcall(function()
		dataStore:SetAsync("TimePlayed_".. player.UserId, timePlayed) --Setting up a Datastore sync for time played.
	end)

	if successRunthrough then
		playerTable.Runthrough = runThrough --Assigns the value of the runthrough to the player's datatable (which will be 0)
	else
		print("Error saving Runthrough: ", errRunthrough) -- or it prints a error if something was wrong with saving/creating runthrough data 
	end

	if successTimePlayed then
		playerTable.Time_Player = timePlayed --Assigns the value of timeplayed to the player's datatable (which is also 0)
	else
		print("Error saving Time Played:", errTimePlayed) --or it prints an error if something was wrong with saving/creating timeplayed data
	end

	--Defining the updatelogs for future use
	local updateLogs = {

		runthroughUpdate = 0, -- These'll be used for more sessionData, not used as of right now but will need in future
		timeplayedUpdate = 0,
		logIns = 0,
		levelUpdate = 0,
		goldUpdate = 0,
		experienceUpdate = 0

	}

	--Combines all data above to a single datatable named "UserData"
	--This is what will be returned to the player when they request their data or after they require new data.
	userData = {
		version = 1,
		profile = playerStats,
		achievements = playerTable,
		trackRecord = updateLogs,
		timeSpent = playerTime
	}
	leaderstats:Create(player, userData) --Creates the leaderboard for the player then assigns the values
	print(userData) --printing the userdata to see if the data got stored properly
	playerData.Data[player.UserId] = userData -- Assign userData to a global variable so you can access it later on
	return userData -- returns the players data
end

--This function will effectively update the user's leaderstat variable. (That is the focus as of right now)
local function dataSaver(player: Player)
	if playerData.Data[player.UserId] ~= nil then
		print("Saving Data . .") --Debug features 1. making sure the function runs at all
		local userData = player.leaderstats
		print(userData.Gold.Value)
		print(playerData.Data[player.UserId])
		if userData then
			if playerData.Data[player.UserId] then
				print("Saving Data . . .") --Debug feature 2. making sure the player data assigned to the player
				local success, errormessage = pcall(function() --protected call to ensure the data saves without issues
					local dataToSave = { --This variable checks the user's leaderstats values Gold and Levels ans assigns them to the variable Gold and Level within the datatable for later use
						Gold = userData.Gold.Value,
						Level = userData.Level.Value
					}
					local logInCounter = playerData.Data[player.UserId].trackRecord.logIns
					logInCounter += 1
					playerData.Data[player.UserId].trackRecord.logIns = logInCounter
					playerData.Data[player.UserId].profile.Gold = dataToSave.Gold -- Later use is here, we're accessing the player's database profile, where all things within the leaderstats are kept and updating the data
					playerData.Data[player.UserId].profile.Level = dataToSave.Level -- Same with Level
					
					playerData.restoreData[player.UserId] = playerData.Data[player.UserId]
					print(playerData.restoreData[player.UserId])
					dataStore:SetAsync("playerData_"..player.UserId, playerData.Data[player.UserId]) -- SetSync to be able to recall the data when player rejoins
					print("Data Saved!") --print statement to let me know the data saved
				end)

				if not success then
					warn("Failed to save Data for player ".. player.Name.. ":", errormessage) --Debug message, letting me know what went wrong
				end
			end
		end
	end
end

--A function that gets the players profile.
function playerData.getProfile(player: Player)
	return playerData.Data[player.UserId]
end

--The wipe function, removing the players saved data, replacing it with an empty table, and kicking them from the server so the playerremoving event takes place.
function playerData.wipeData(player: Player, data)
	Players.PlayerRemoving:Connect(function(player)
		playerData.Data[player.UserId] = nil
		dataStore:RemoveAsync("playerData_" .. player.UserId)
	end)
	player:Kick("Data has Been Wiped!")
end

--function to store a players data, after storing their data, they'll be assigned default data! They can play around with it and then before they leave, they can restore their original data.
function playerData.store(player: Player, data)
	print("Running")
	dataStore:SetAsync("StoreData_" .. player.UserId, data) -- stores their current data within the datastore
	print(data)
	print(playerData.Data[player.UserId])
	--Resetting every and any data the player may have
	playerData.Data[player.UserId] = nil
	data = nil
	removeFolder(player)
	playerData.createProfile(player)
end

--function to recall the saved data above
function playerData.recallSavedData(player: Player)
	local success, data = pcall(function()
		return dataStore:GetAsync("StoreData_" .. player.UserId)
	end)
	
	if success and data then
		print(success)
		print(data)
		playerData.Data[player.UserId] = data
		print(playerData.Data[player.UserId])
		removeFolder(player)
		leaderstats:Create(player, playerData.Data[player.UserId])
		print(data)
		dataStore:RemoveAsync("StoreData_" .. player.UserId)
	end
	
	if not success and data then
		warn("No Data to recall")
	end
end

--Function to keep track of how long a player has been playing your game! (I suck with GUI so I made it as minimal as possible)
local function startTimer(player: Player, elapseTime)
	local secondstoMinutesandMinutestoHours = 60
	local hourstoDays = 24
	local secondsCounter = 0
	local minutesCounter = 0
	local hoursCounter = 0
	local daysCounter = 0
	
	while playerData.runningTimer == true do
		wait(1)
		elapseTime = playerData.Data[player.UserId].timeSpent.seconds --grab the seconds the player may already have within the game and set that to elapse time aka the start time
		elapseTime += 1
		playerData.Data[player.UserId].timeSpent.seconds = elapseTime
		getPlayerData:FireClient(player, elapseTime)
		
		if elapseTime >= secondstoMinutesandMinutestoHours then
			elapseTime = 0
			minutesCounter = playerData.Data[player.UserId].timeSpent.minutes
			minutesCounter += 1
			playerData.Data[player.UserId].timeSpent.seconds = secondsCounter
			playerData.Data[player.UserId].timeSpent.minutes = minutesCounter
			getMinutes:FireClient(player, minutesCounter)
			
			if minutesCounter >= secondstoMinutesandMinutestoHours then
				minutesCounter = 0
				hoursCounter = playerData.Data[player.UserId].timeSpent.hours
				hoursCounter += 1
				playerData.Data[player.UserId].timeSpent.minutes = minutesCounter
				playerData.Data[player.UserId].timeSpent.hours = hoursCounter
				
				if hoursCounter >= hourstoDays then
					hoursCounter = 0
					daysCounter = playerData.Data[player.UserId].timeSpent.days
					daysCounter = 1
					playerData.Data[player.UserId].timeSpent.hours = hoursCounter
					playerData.Data[player.UserId].timeSpent.days = daysCounter
				end
			end
		end
	end
end

--A function to stop the timer above by setting the variable that keeps the timer running to false
local function stopTimer()
	playerData.runningTimer = false
end

Players.PlayerAdded:Connect(playerAdded) -- Runs the playerAdded function when a player joins the game
--This player added function starts the timer when the player joins
Players.PlayerAdded:Connect(function(player)
	task.wait(5)
	local timer = playerData.Data[player.UserId].timeSpent.elasTime
	coroutine.wrap(startTimer)(player, timer) --coroutine wrapped it so it can play in the background
end)

Players.PlayerRemoving:Connect(dataSaver) -- runs dataSaver when player Leaves
--This player leaving function stops the timer when the player leaves
Players.PlayerRemoving:Connect(function(player)
	stopTimer()
end)

return playerData --Returns the player modules
